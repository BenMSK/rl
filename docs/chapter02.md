---
layout: page
group: "Chapter. 2"
title: "2. Dynamic Programming (DP)"
---

- Dynamic Programming(이하 DP)은 우리말로 동적 프로그래밍(DP)이라고 한다.
- RL에서는 기본적으로 확률 동적 프로그래밍 (Probabilistic Dynamic Programming) 기법을 사용하게 된다.
    - 즉, 기본적인 DP 모델에 확률 이론이 포함된다는 이야기이다.
- 따라서 여기서는 먼저 간단하게 동적 프로그래밍(DP)이 뭔지 확인해보고 넘어가도록 하자.
    - 물론 동적 프로그래밍을 이해하기 위해서는 먼저 결정적 프로그래밍(deterministic programming) 방식을 이해하고 있어야 한다.
        - 여기서는 이런것까지 언급할 시간이 없다. 바로 동적 프로그래밍이 뭔지만 보고 넘어가도록 하자.
        - 물론 학교 다닐때 다 배운 내용이기도 하다. (예를 들어 *BFS* , *DFS* 등이 대표적인 결정적 프로그래밍 기법.)
        - 최단거리 같은거 많이 구해보았을 것이다.
    
### 동적 프로그래밍의 기초

- 최적화 기법 중 하나로 재귀(recursion)를 이용하여 최적화 솔루션을 얻어내는 방식을 사용한다.
- 동적 프로그래밍으로 풀 수 있는 가장 유명한 문제로 배낭 문제(Knapsack problem)를 들 수 있다.
- 이것만 살펴보면 DP를 쉽게 이해할 수 있다.

### 0-1 Knapsack problem

- **문제 정의**
    - 배낭이 하나 있다고 하자. 이 때 배낭에 담을 수 있는 부피 용량은 \\(W\\) 이다. (단, \\(W>0\\) 이다.)
    - 배낭에 담을 수 있는 아이템(item)도 \\(n\\) 개를 가지고 있다. 최대한 많은 아이템을 배낭에 담아야 한다.
    - 이 때 아이템(item) \\(i\\) 는 2개의 속성 값을 가지고 있다.
        - \\(w\_i\\) : 아이템의 용량
        - \\(v\_i\\) : 아이템의 중요도 (즉, 가중치)
        - 물론 용량이 클수록 중요도가 커진다거나 하는 것은 아니다.
    - *목표* : 최대한 중요한 아이템을 선별하여 배낭에 담도록 하자. 
        - 단, 각각의 아이템은 쪼갤 수 없다. 오로지 배낭에 담을지 말지만 결정 가능하다.
            - 그래서 문제 제목에 0-1 이 있는 것이다.
    - \\(n\\) 개의 아이템을 \\(T=\{1,2,...n\}\\) 이라고 하면
        - \\(\(\sum\_{i \in T} w\_i) \le W\\) 의 제약 하에,
        - \\(\max(\sum\_{i \in T}v\_i)\\) 를 만족하는 \\(T\\) 의 부분집합을 구해야 한다.
    - 단순하게 생각하여 조합 가능한 \\(T\\) 의 부분집합 갯수를 고려하면 모두 \\(2^n\\) 개의 부분 집합이 나온다.
    - 이를 동적 프로그래밍을 이용하여 풀어보고, 이후에 확률론을 접목시킨 확률 동적 프로그래밍이 무엇인지 살펴볼 것이다.
        - 아래에서 바로 확인하겠지만 동적 프로그래밍이란 결국 주어진 문제를 더 작은 단위의 문제로 나누고 (D&C),
        - 중간 계산 과정을 잠시 어딘가에 저장해 두었다가 사용을 하는 최적화 풀이 알고리즘이다.
        - 결국 공간(space)과 시간(time)을 트레이드 오프하는 알고리즘이 된다.
    
#### Step 1.

- 문제를 더 작은 단위의 문제들로 나눈다.
- 일단 목표 달성을 위한 평가 배열 \\(V[(0...n),(0...W)]\\) 를 정의한다. ( \\(1 \le i \le n\\) 이고 \\(0 \le w \le W\\) 이다.)
    - 단순히 목적 함수를 쉽게 나타내기 위한 수단이므로 너무 어렵게 고민하지는 말자.
    - \\(V[i,w]\\) 를 정의해보자.
        - \\(V\\) 는 실수 값을 저장하는 2차원 배열이라고 생각하면 된다.
        - 각각의 공간에는 어떤 값을 저장할 것인데,
            - 집합 \\(\{1,2,...,i\}\\) 의 어떤 부분 집합에 대해서 \\(V[i,w]\\) 는 이 부분집합으로 만들어 낼 수 있는 \\(v\\) 값 중 최대값을 저장할 것이다.
            - 이 때 이 부분 집합으로 구성 가능한 부피의 최대 값이 \\(w\\) 이다. 
            - 예를 들어 \\(V[2, 20]\\) 이라는 의미는 1번, 2번 아이템만으로 총 부피 20 이내의 모든 부피에 대해 가능한 최대 이득을 저장하게 된다.
            - (표기법이 좀 허술해도 이해해달라. 10년전 자료를 정리해서 그렇다.)
    - 따라서 문제 정의에 따라 \\(V[n,W]\\) 를 구하는게 우리의 목표가 된다.
        - 즉, \\(n\\) 아이템의 부분 집합 중 용량 \\(W\\) 에 가장 근접하는 부분 집합의 최대 \\(v\\) 값을 단순하게 \\(V[n,W]\\) 로 표현할 수 있다는 것이다.
        - 왜 이딴 식으로 정의를 했는지는 문제 풀이를 보면 알 수가 있다.

#### Step 2.

- 작게 나누어진 문제들의 풀이들을 재귀적인 방식으로 정의하도록 하자.
- 다음과 같이 우선 초기 조건을 정의한다.

$$V[0, w]=0, \qquad for\;\;0 \le w \le W\;(no\;item)$$

$$V[i,w]=-\infty,\qquad for\;\; w \le 0\;(illegal)$$

- 이제 이 외의 경우들을 재귀 함수를 통해 정의해보도록 하자.

$$V[i,w]= \max\left\{V[i-1, w]\;,\; v_i + V[i-1, w-w_i] \right\}\\for\;\; 1 \le i \le n, 0 \le w \le W$$

- 곰곰히 생각해보면 알겠지만 어차피 모든 경우의 수를 고려해야 한다.
    - 하지만 각각의 경우 수에 따라 중간 계산 내용이 동일한 경우가 많다. 
    - 이전에 계산한 결과들을 별도의 \\(V\\) 테이블에 저장을 하여 두고 나중에 재사용한다는 것이다.
- 아래 그림을 보면 \\(i=0\\) 인 상태에서부터 \\(i=n\\) 인 상태까지 모든 가능한 결과를 테이블 \\(V\\) 에 저장하게 된다.
- 임의의 \\(i\\) 위치에서는 이전의 결과 값을 이용하여 현재 상태에서의 최적 값을 찾고 이 때의 이전 값의 위치를 저장하게 되는 것이다.

![figure2.1]({{ site.baseurl }}/images/ch02_f01.png){:class="center-block" height="200px"}

- 작업은 보통 bottom-up 방식의 계산으로 풀이를 진행한다.
- 실제 예제를 보자.

![figure2.2]({{ site.baseurl }}/images/ch02_f02.png){:class="center-block" height="300px"}

- 구체적인 예를 통해 확인하는게 가장 쉽다.
- 현재 아이템은 총 4개이고 \\(i\\)로 표현한다. 각각의 무게와 가치가 기술되어 있다.
- 이제 위의 예제에서 ( \\(i=3\\) )인 아이템을 넣는 상황을 고려해보자. (즉, 아이템 1, 2, 3으로 가방을 채움)
    - 이 시점에서는 아이템 1만으로 모든 부피에 대해 얻을 수 있는 최대 이득이 ( \\(i=1\\) ) 열(row)에 기술되어 있다.
    - 또한 아이템 1과 2만으로 모든 부피에 대해 얻을 수 있는 최대 이득도 ( \\(i=2\\) ) 열에 기술되어 있다.
    - 이제 ( \\(i=3\\) ) 아이템을 계산할 때 처음부터 모든 경우의 수를 다시 계산하는 것이 아니라,
    - ( \\(i=2\\) ) 인 상황에서 이 아이템을 넣을 때와 뺄 때의 경우만 고려하면 ( \\(i=3\\) ) 에서의 결과를 쉽게 계산할 수 있다.

- 이제 최종 결과 값을 \\(V[4, 10]=90\\) 이라고 생각할 수 있다.

- - -

- 이 정도로 동적 프로그램을 살짝 맛고보만 넘어간다.
    - 일단은 Tree 형태의 탐색 방식을 가지고 있다는 정도만 보면 된다. 그리고 재귀로 푼다는 사실을 잊지 말자.
    - 이런 식으로 프로그래밍을 한번이라도 해봤던 사람이라면 쉽게 이해할 수 있다.

- 여기서 중요한 포인트는 문제를 재귀적인 형태로 해결하고 있다는 것.
    - 마찬가지로 MDP에서도 문제를 재귀적인 형태로 변경하여 문제 풀이를 진행하게 된다.
- 그리고 모든 상태에 대해 최적의 결과를 모두 어딘가에 '저장' 하고 있다는 사실도 잊지말자.
